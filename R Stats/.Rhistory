stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
dorsPower$INT<-interaction(dorsPower$sysName, dorsPower$bandName)
stepPower$INT<-interaction(stepPower$sysName, stepPower$bandName)
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1|partNum), dorsPower)
dorsPowerModelINT<-lm(value~ -1 + INT, data=dorsPower)
# Model for step on/off
stepPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, stepPower)
stepPowerModelINT<-lm(value~ -1 + INT, data=stepPower)
plot(dorsPowerModel)
summary(dorsPowerModel)
Anova(dorsPowerModel)
omega_sq(dorsPowerModel, ci.lvl = 0.95, n = 2000, partial = TRUE)
icc(dorsPowerModel)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
powerRatio$INT<-interaction(powerRatio$sysName,powerRatio$bandName)
# Model for power ratio
ratioModel <- lm(value ~ sysName + bandName + sysName*bandName, powerRatio)
ratioModelINT<-lm(value~ -1 + INT, data=powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
dorsPower$INT<-interaction(dorsPower$sysName, dorsPower$bandName)
stepPower$INT<-interaction(stepPower$sysName, stepPower$bandName)
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1|partNum), dorsPower)
dorsPowerModelINT<-lm(value~ -1 + INT, data=dorsPower)
# Model for step on/off
stepPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1|partNum), stepPower)
stepPowerModelINT<-lm(value~ -1 + INT, data=stepPower)
summary(stepPowerModel)
Anova(stepPowerModel)
icc(stepPowerModel)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
powerRatio$INT<-interaction(powerRatio$sysName,powerRatio$bandName)
# Model for power ratio
ratioModel <- lmer(value ~ sysName + bandName + sysName*bandName, powerRatio)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
powerRatio$INT<-interaction(powerRatio$sysName,powerRatio$bandName)
# Model for power ratio
ratioModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), powerRatio)
ratioModelINT<-lm(value~ -1 + INT, data=powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
dorsPower$INT<-interaction(dorsPower$sysName, dorsPower$bandName)
stepPower$INT<-interaction(stepPower$sysName, stepPower$bandName)
# Model for dorsiflexion
dorsPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, dorsPower)
dorsPowerModelINT<-lm(value~ -1 + INT, data=dorsPower)
# Model for step on/off
stepPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, stepPower)
stepPowerModelINT<-lm(value~ -1 + INT, data=stepPower)
icc(ratioModel)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
powerRatio$INT<-interaction(powerRatio$sysName,powerRatio$bandName)
# Model for power ratio
ratioModel <- lmer(value ~ (1| sysName) + (1|bandName) + (1 | partNum), powerRatio)
ratioModelINT<-lm(value~ -1 + INT, data=powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
dorsPower$INT<-interaction(dorsPower$sysName, dorsPower$bandName)
stepPower$INT<-interaction(stepPower$sysName, stepPower$bandName)
# Model for dorsiflexion
dorsPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, dorsPower)
dorsPowerModelINT<-lm(value~ -1 + INT, data=dorsPower)
# Model for step on/off
stepPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, stepPower)
stepPowerModelINT<-lm(value~ -1 + INT, data=stepPower)
icc(ratioModel)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
powerRatio$INT<-interaction(powerRatio$sysName,powerRatio$bandName)
# Model for power ratio
ratioModel <- lm(value ~ sysName + bandName + sysName*bandName, powerRatio)
ratioModelINT<-lm(value~ -1 + INT, data=powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
dorsPower$INT<-interaction(dorsPower$sysName, dorsPower$bandName)
stepPower$INT<-interaction(stepPower$sysName, stepPower$bandName)
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), dorsPower)
dorsPowerModelINT<-lm(value~ -1 + INT, data=dorsPower)
# Model for step on/off
stepPowerModel <- lm(value ~ sysName + bandName + sysName*bandName, stepPower)
stepPowerModelINT<-lm(value~ -1 + INT, data=stepPower)
plot(ratioModel)
summary(ratioModel)
Anova(ratioModel)
omega_sq(ratioModel, ci.lvl = 0.95, n = 2000, partial = TRUE)
plot(dorsPowerModel)
summary(dorsPowerModel)
Anova(dorsPowerModel)
omega_sq(dorsPowerModel, ci.lvl = 0.95, n = 2000, partial = TRUE)
summary(glht(dorsPowerModelINT, linfct = mcp(INT = "Tukey")))
plot(dorsPowerModel)
summary(dorsPowerModel)
Anova(dorsPowerModel)
omega_sq(aov(dorsPowerModel), ci.lvl = 0.95, n = 2000, partial = TRUE)
plot(ratioModel)
summary(ratioModel)
Anova(ratioModel)
omega_sq(ratioModel, ci.lvl = 0.95, n = 2000, partial = TRUE)
summary(ratioModel)
summary(dorsPowerModel)
Anova(dorsPowerModel)
dorsPowerModel
knitr::opts_chunk$set(echo = TRUE)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for power ratio
ratioModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), dorsPower)
# Model for step on/off
stepPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName+ (1 | partNum), stepPower)
plot(ratioModel)
summary(ratioModel)
Anova(ratioModel)
omega_sq(ratioModel, ci.lvl = 0.95, n = 2000, partial = TRUE)
ggqqplot(ratioModel)
ggqqplot(resid(ratioModel))
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for power ratio
ratioModel <- glmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), powerRatio, family = Gamma(link = "log"))
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), dorsPower)
# Model for step on/off
stepPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName+ (1 | partNum), stepPower)
ggqqplot(resid(ratioModel))
Anova(ratioModel)
# Load packages
rm(list = ls())
require(ggplot2)
require(lme4)
require(car)
require(MASS)
require(lme4)
require(sjstats)
require(fBasics)
require(ggpubr)
require(reshape2)
require(phia)
require(lsmeans)
require(multcomp)
# function for is nan
is.nan.data.frame <- function(x)
do.call(cbind, lapply(x, is.nan))
# Load data <PowerTable.csv>
dataSource <- read.csv("../Data/Step V/PowerTable.csv")
dataSource[is.nan(dataSource)] <- NA
dataSource$partNum <- as.factor(dataSource$partNum)
dataSource$sessNum <- as.factor(dataSource$sessNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$sysNum <- as.factor(dataSource$sysNum)
dataSource$mvNum <- as.factor(dataSource$mvNum)
dataSource$paraNum <- as.factor(dataSource$paraNum)
# Create data subsets
selfPacedData <- subset(dataSource, paraNum == 1)
validityData <- subset(selfPacedData, sessNum != 4)
# Add names for systems and movements.
validityData$mvName <- factor(validityData$mvNum, labels = c("Dorsiflexion", "Step on/off"))
validityData$sysName <- factor(validityData$sysNum, labels = c("Gold Standard", "Prototype"))
# Find power ratio
dorsPower <- subset(validityData, mvNum == 1)
stepPower <- subset(validityData, mvNum == 2)
powerRatio <- stepPower # mvNum is meaningless in this dataframe
powerRatio[,6:9] <- stepPower[,6:9] / dorsPower[,6:9]
powerRatio <- melt(powerRatio, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for power ratio
ratioModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), powerRatio)
# Setup movement power for models
dorsPower <- melt(dorsPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
stepPower <- melt(stepPower, id.vars = c("partNum", "sessNum", "sysName"),
measure.vars = c("PWR_d", "PWR_t", "PWR_a", "PWR_b"),
variable.name = "bandName")
# Model for dorsiflexion
dorsPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName + (1 | partNum), dorsPower)
# Model for step on/off
stepPowerModel <- lmer(value ~ sysName + bandName + sysName*bandName+ (1 | partNum), stepPower)
plot(ratioModel)
library(lsmeans)
lsmeans(ratioModel, pairwise ~ sysName | bandName)
??lsmeans
lsmeans(ratioModel, pairwise ~ bandName | sysName)
install.packages("lmerTest")
install.packages("lmerTest")
lsmeans(ratioModel, pairwise ~ bandName | sysName)
help('lsmeans')
lsmeans(ratioModel, pairwise ~ bandName | sysName)
lsmeans(ratioModel, pairwise ~  sysName | bandName)
lsmeans(ratioModel, pairwise ~  sysName | bandName, adjust = "tukey")
citation('lme4')
??glmer
citation('lsmeans')
??lsmeans
version('lsmeans')
version('lme4')
??lme4
??Anova
help('Anova')
View(powerRatio)
View(dorsPower)
